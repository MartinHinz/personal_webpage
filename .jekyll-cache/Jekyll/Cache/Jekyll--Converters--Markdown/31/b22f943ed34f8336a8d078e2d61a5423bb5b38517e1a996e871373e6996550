I"!Â<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<h1 id="appetizer">Appetizer</h1>

<p>With what follows I want to demonstrate that the basic functionality of Oxcal is reflected in this tiny bit of code:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">calf</span><span class="o">&lt;-</span><span class="n">approxfun</span><span class="p">(</span><span class="n">intcal13</span><span class="p">[,</span><span class="m">1</span><span class="p">],</span><span class="n">intcal13</span><span class="p">[,</span><span class="m">2</span><span class="p">])</span><span class="w">

</span><span class="n">likelihood</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">proposal</span><span class="p">){</span><span class="n">dnorm</span><span class="p">(</span><span class="n">calf</span><span class="p">(</span><span class="n">proposal</span><span class="p">),</span><span class="n">bp</span><span class="p">,</span><span class="n">std</span><span class="p">)}</span><span class="w">

</span><span class="c1">#Setup</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3600</span><span class="p">;</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="p">;</span><span class="w"> </span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span><span class="w">

</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">)</span><span class="w">
  </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span><span class="w">
  
  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">proposal_prob</span><span class="o">/</span><span class="n">last_prob</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="w"> </span><span class="n">proposal</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<!--more-->

<h1 id="motivation">Motivation</h1>

<h2 id="the-c-cycle">The ¬π‚Å¥C cycle</h2>

<p>¬π‚Å¥C is produced in the atmosphere by solar radiation, is than oxidised to CO<sub>2</sub> and than introduced into the foodchain. From than onward, the ¬π‚Å¥C decays.</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/radiocarbon.png" alt="" /></p>

<p class="caption">source: http://www.imprs-gbgc.de/uploads/RadiocarbonSchool/Overview/radiocarbon.png</p>

<h2 id="the-nonlinear-nature-of-the-c-curve">The nonlinear nature of the ¬π‚Å¥C curve</h2>

<p>The problem is, that the amount of ¬π‚Å¥C in the atmosphere was different during different times. This causes that there is no simple linear relationship between ¬π‚Å¥C years you get from the lab to the real calendric cal bp or bc date. The expression of this is the wiggly nature of the calibration curve:</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-2-1.png" alt="" />
<!-- --></p>

<p>This becomes more obvious if we zoom in:</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-3-1.png" alt="" />
<!-- --></p>

<h2 id="changes-in-solar-activity">changes in solar activity</h2>

<p>The main reason for that might be the fluctuation of the solar activity, that causes different amount of solar radiation and with that also different ¬π‚Å¥C values. One fluctuation is a well known 11 year cycle, but there are other, not so well behaving fluctuations, too.</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/The_Solar_Cycle_XRay_hi.jpg" alt="" /></p>
<p class="caption">A solar cycle<br />source: https://upload.wikimedia.org/wikipedia/commons/c/c2/The_Solar_Cycle_XRay_hi.jpg</p>

<h2 id="calibration--using-material-of-known-age">calibration | using material of known age</h2>

<p>To cope with that, we use samples of known age, eg. tree rings. Radiometric dating those gives us a estimation for the amount of ¬π‚Å¥C at different times. Since the resulting calibration curve is not linear, there is no linear calculation possible to come up with the real age of things.</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/Crossdating1.png" alt="" /></p>
<p class="caption">Dendrochronology<br />source: Schweingruber, F.H., 1983: Der Jahrring. Haupt, Bern und Stuttgart</p>

<h2 id="real-world-calibration--the-problem-with-the-nonlinear-nature">Real world calibration | The problem with the nonlinear nature</h2>

<p>In an ideal world, you could use a ruler for translating a radiocarbon age to a calender age. But due to the wiggles of the curve, there are parts where a radiocarbon age could result in two or even more possible calendric ages.</p>

<video controls="" loop=""><source src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/calib_anim-.mp4" /><p>video of chunk calib_anim</p></video>

<h2 id="real-world-calibration--the-problem-nature-of-a-c-date">Real world calibration | The problem nature of a ¬π‚Å¥C date</h2>

<p>What makes things worse, is the fact, that you will never get a single radiocarbon age, but always a probability distribution with a ‚Äòmost likely‚Äô value (the uncalibrated ¬π‚Å¥C age) with a standard deviation (eg. +/- 25). On the pro side is that this distribution behaves statistically well, since it follows a normal distribution. On the con side: this enlarges the possible range where a calibration gives multiple values, and it makes the calculation non-trivial.</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/calib_anim2-1.png" alt="" /><!-- --></p>

<p>There are several approaches for calibration, one I have shown in an earlier post, this time we will deal with the Bayesian way.</p>

<h1 id="the-bayesian-approach-to-that-problem">The bayesian approach to that problem</h1>

<h2 id="keywords">Keywords</h2>

<p>There are several buzzwords that show up when people talk about Bayesian calibration. Those are eg.</p>

<ul>
  <li>Monte Carlo</li>
  <li>Markov Chain</li>
  <li>Metropolis‚ÄìHastings algorithm</li>
</ul>

<p>The sound impressive, don‚Äôt they. But we will handle them one by one.</p>

<h2 id="monte-carlo">Monte Carlo</h2>

<div class="columns-2">
<div style="float:left; min-width: 40%">
<img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/dice.png" width="200px" />
</div>
<div style="min-width: 40%">
Monte Carlo methods are just a name for 'doing something including a random aspect', meaning eg. 'roll a dice'.
</div>
</div>
<div style="clear:both"></div>

<h2 id="markov-chain">Markov Chain</h2>

<div class="columns-2">
<div style="float:left; min-width: 40%">
<img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/Markov_Chain_weather_model_matrix_as_a_graph.png" width="350px" />
</div>
<div style="min-width: 40%">
Markov Chain means 'Something takes place in respect to the current state'. In this example, we start from a sunny day. There is a 90% chance that the next day will be sunny again, and a 10% chance that it will be raining. If the next day will be one of those 10% where it is rainy, there is a 50% chance that it stays rainy, and a 50% chance that it will be sunny again. So, next day is rainy, again 50/50 chances. If next day is sunny, again 90/10 chances. And so on.
</div>
</div>
<div style="clear:both"></div>

<h2 id="together-it-is-mcmc">Together it is MCMC</h2>

<p>MCMC stands for ‚ÄòMonte Carlo Markov Chain‚Äô. This is a procedure that can be used for estimating parameter that can not be measured directly, based on an external evaluation.</p>

<p>To demonstrate that and to prepare for the real ¬π‚Å¥C calibration, we will estimate the value of Pi.</p>

<h1 id="excurse-value-of-pi-using-mcmc">Excurse Value of Pi using MCMC</h1>

<h2 id="setting">Setting</h2>

<p>We have a square of 1 m and an circle with radius 1 m.</p>

<p>We throw darts.
We count, how many darts are in the circle, and how many are in the surrounding square.</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-4-1.png" alt="" />
<!-- --></p>

<p>The darts are the random part (Monte Carlo). The amount of darts inside the circle is relative to the area, as it is the amount of darts within the square.</p>

<p>area of circle to area of square is:</p>

<p>\(\frac{\text{area of circle}}{\text{area of square}} = \frac{ r^{2} \cdot \pi }{ (2 \cdot r)^{2} } = \frac{ \pi }{ 4 } = \frac{\text{darts in circle}}{\text{darts in square}} = P\)
<br />
\(\pi = P \cdot 4\)</p>

<p>To calculate the value of Pi, we have to count the darts that are inside the circle and those inside the square, and divide their ratio by 4.</p>

<h2 id="experiment">Experiment</h2>

<p>Now some R code follows:</p>

<p>We make a circle with radius of 0.5 and center it in a square (center = 0.5;0.5). We make a loop, that is repeated 10000 times. We randomly draw from a uniform distribution x and y for the point (we throw the dart). We check if the dart is inside the circle. If so, we memorize it. Afterwards, we divide the amounts of dart inside the circle by the number of trials, divided by 4.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">radius</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">center_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">center_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">()</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">inside</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center_x</span><span class="p">)</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">center_y</span><span class="p">)</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">radius</span><span class="o">^</span><span class="m">2</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="n">inside</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="nf">sum</span><span class="p">(</span><span class="n">collector</span><span class="o">==</span><span class="kc">TRUE</span><span class="p">)</span><span class="o">/</span><span class="nf">length</span><span class="p">(</span><span class="n">collector</span><span class="p">)</span><span class="o">*</span><span class="m">4</span><span class="w">
</span></code></pre></div></div>

<p>The result:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## [1] 3.1208</span><span class="w">
</span></code></pre></div></div>

<p>is close to Pi:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">pi</span><span class="w">
</span><span class="c1">## [1] 3.141593</span><span class="w">
</span></code></pre></div></div>

<h2 id="experiment-live">Experiment Live</h2>

<p>Here you can see the experiment running live:</p>

<video controls="" loop=""><source src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/pi_2-.mp4" /><p>video of chunk pi_2</p></video>

<h2 id="anatomy-of-the-algorithm">Anatomy of the algorithm</h2>

<p>The algorithm we have used can be divided into several parts:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Setup</span><span class="w">
</span><span class="n">radius</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">center_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">center_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">()</span><span class="w">

</span><span class="c1"># Loop</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  
  </span><span class="c1"># Proposal (function)</span><span class="w">
  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
  
  </span><span class="c1"># Likelihood (function)</span><span class="w">
  </span><span class="n">inside</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center_x</span><span class="p">)</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">center_y</span><span class="p">)</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">radius</span><span class="o">^</span><span class="m">2</span><span class="w">
  
  </span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="n">inside</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>A setup, where we define start values</li>
  <li>A loop, within which things are repeated for some time</li>
  <li>A proposal function, that proposes candidates for our ‚Äòdesired‚Äô result (darts in the circle).</li>
  <li>A likelihood function that determinates how likely it is that we archived a ‚Äòdesired‚Äô result. In this case it is either in or out, so likelihood is either 0 or 1.</li>
  <li>At last, a collector, that collects our results.</li>
</ul>

<h2 id="pi-vs-c-date">Pi vs ¬π‚Å¥C Date</h2>

<p>In this experiment, there are already several aspects that are similar to the ¬π‚Å¥C calibration that we intend to produce, but also some differences that we have to cope with:</p>

<table>
  <thead>
    <tr>
      <th>Pi</th>
      <th>¬π‚Å¥C Date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>unknown value of Pi</td>
      <td>unknown distribution of calibrated date</td>
    </tr>
    <tr>
      <td>choosing a random point</td>
      <td>choosing a random date</td>
    </tr>
    <tr>
      <td>evaluation against the circle (inside/outside)</td>
      <td>evaluation against the uncalibrated date</td>
    </tr>
    <tr>
      <td>deterministic evaluation criterion (inside/outside)</td>
      <td>probabalistic criterion (prob. distribution of uncalibrated date)</td>
    </tr>
  </tbody>
</table>

<p>¬†</p>

<p>With some little effort we will be able to proceed from here to Bayesian calibration.</p>

<h1 id="toward-the-bayesian-calibration">Toward the Bayesian calibration</h1>

<p>Lets start with things that are similar:</p>

<h2 id="setup">Setup</h2>

<p>Setup looks rather similar. We only need different things, like uncalibrated date and its standard deviation.</p>

<div class="columns-2">
<div style="float:left; min-width: 50%">
    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pi</span><span class="w">
</span><span class="n">radius</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">center_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">center_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.5</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">()</span><span class="w">
</span></code></pre></div>    </div>
  </div>

<div style="float:left; min-width: 50%">
    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calibration</span><span class="w">
</span><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3600</span><span class="w">
</span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">()</span><span class="w">
</span><span class="n">collector</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bp</span><span class="w">
</span></code></pre></div>    </div>
  </div>
</div>
<div style="clear:both"></div>

<h2 id="loop">Loop</h2>

<p>Also the loop is rather similar:</p>

<div class="columns-2">
<div style="float:left; min-width: 50%">

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pi</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Actions that are repeated</span><span class="w">
  </span><span class="c1"># 10000 times</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </div>

<div style="float:left; min-width: 50%">

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calibration</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Actions that are repeated</span><span class="w">
  </span><span class="c1"># 10000 times</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </div>
</div>
<div style="clear:both"></div>

<h2 id="proposal-function">Proposal function</h2>

<p>In case of Pi, we propose random x and y coordinates. For the calibration, we propose a calendric date. But we do not propose any random date, but one that depends on our previous proposal. This is a Markov Chain, remember? We make a new proposal near to our previous one, and we make it more likely that it is nearer than that it is farther away. For that we use a normal distribution (rnorm).</p>

<div class="columns-2">
<div style="float:left; min-width: 50%">

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pi</span><span class="w">

</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

  </div>

<div style="float:left; min-width: 50%">

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calibration</span><span class="w">
</span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="w">
  </span><span class="m">1</span><span class="p">,</span><span class="w">
  </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w">
  </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
  </div>
</div>

<div style="clear:both"></div>

<video autoplay="" loop=""><source src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/proposal_function_live-.mp4" /><p>video of chunk proposal_function_live</p></video>

<h2 id="putting-together-what-we-have-now">Putting together what we have now:</h2>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3600</span><span class="w">
</span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">()</span><span class="w">
</span><span class="n">collector</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bp</span><span class="w">
 
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">)</span><span class="w">
  
  </span><span class="c1"># What is missing is the likelihood function!</span><span class="w">
  
  </span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="w"> </span><span class="n">proposal</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="differences-to-the-pi-example">Differences to the Pi example</h2>

<p>From now on, things are a bit different due to the differences of our examples:</p>

<table>
  <thead>
    <tr>
      <th>Pi</th>
      <th>¬π‚Å¥C Date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>unknown value of Pi</td>
      <td>unknown distribution of calibrated date</td>
    </tr>
    <tr>
      <td>choosing a random point</td>
      <td>choosing a random date</td>
    </tr>
    <tr>
      <td>evaluation against the circle (inside/outside)</td>
      <td><strong>evaluation against the uncalibrated date</strong></td>
    </tr>
    <tr>
      <td>deterministic evaluation criterion (inside/outside)</td>
      <td><strong>probabalistic criterion (prob. distribution of uncalibrated date)</strong></td>
    </tr>
  </tbody>
</table>

<p>We cannot directly evaluate, if the date fits our calibrated date, because we do not know it yet. But we know the uncalibrated date, and will use that instead. Also, we do not have a inside/outside of the circle criterion (0/1), but one that has a certain probability, so values between 0 and 1 are possible. We will cope with that.</p>

<h2 id="differences-to-the-pi-example-1">Differences to the Pi example</h2>

<h3 id="problem-one">Problem One</h3>
<p>We evaluate against the uncalibrated date:</p>

<p>-&gt; We have to backcalibrate the proposal</p>

<h3 id="problem-two">Problem Two</h3>
<p>We have a probabilistic criterion, we only get a probability back if the proposal fits our uncalibrated date</p>

<p>-&gt; We have to introduce some probabilistic (random) decision</p>

<h2 id="solution-one-backward-calibration">Solution One: Backward calibration</h2>

<p>In contrast to forward calibration, backward calibration is straight forward. We can use the ‚Äòruler approach‚Äô, since every calibrated date only reflects one uncalibrated one. The wiggles only go up and down, luckily not left and right!</p>

<video autoplay="" loop=""><source src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/backcalib_anim-.mp4" /><p>video of chunk backcalib_anim</p></video>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">intcal13</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="w">
  </span><span class="s2">"http://www.radiocarbon.org/IntCal13%20files/intcal13.14c"</span><span class="p">,</span><span class="w">
  </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="o">=</span><span class="nb">F</span><span class="p">)[,</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">]</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">intcal13</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"CAL BP"</span><span class="p">,</span><span class="w"> </span><span class="s2">"14C age"</span><span class="p">)</span><span class="w">

</span><span class="n">calf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">this_bp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">approx</span><span class="p">(</span><span class="n">intcal13</span><span class="o">$</span><span class="n">`CAL BP`</span><span class="p">,</span><span class="w">
         </span><span class="n">intcal13</span><span class="o">$</span><span class="n">`14C age`</span><span class="p">,</span><span class="w">
         </span><span class="n">this_bp</span><span class="p">)</span><span class="o">$</span><span class="n">y</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">calf</span><span class="p">(</span><span class="m">3600</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 3364
</code></pre></div></div>

<h2 id="likelihood-function">Likelihood function</h2>

<p>For the likelyhood function, we need the shape of the uncalibrated date. With that we can now check how good a proposed date would fit our uncalibrated one. We can determine, how likely a proposal would be given our uncalibrated date.</p>

<div class="columns-2">
<div style="float:left; min-width: 50%">
    <p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/uncal_curve 3-1.png" alt="" /><!-- --></p>
  </div>
<div style="float:left; min-width: 50%">
    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">likelihood</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">proposal</span><span class="p">){</span><span class="w">
 </span><span class="n">pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calf</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span><span class="w">
 </span><span class="n">dnorm</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span><span class="n">bp</span><span class="p">,</span><span class="n">std</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">likelihood</span><span class="p">(</span><span class="m">3600</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 4.85012e-16
</code></pre></div>    </div>
  </div>
</div>
<div style="clear:both"></div>

<p>With that, we have a likelihood function!</p>

<h2 id="solution-two-evaluation-with-a-random-component">Solution Two: Evaluation with a random component</h2>

<ul>
  <li>We take the last proposal, resp. its likelihood</li>
  <li>We compute the likelihood of the new proposal</li>
  <li>If the new proposal fits better to the uncalibrated date, we keep it</li>
  <li>If not: We still keep it with a probability equal to how worse the new proposal is compared to the prior one</li>
</ul>

<p><strong>p(new)/p(old)</strong></p>

<p><strong>-&gt; Metropolis-Hastings algorithm</strong></p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/dice.png" height="150px" style="float:right; margin-top: -100px;" /></p>

<div style="clear:both"></div>

<h2 id="solution-two-evaluation-with-a-random-component-1">Solution Two: Evaluation with a random component</h2>

<p>We start with the bp value of the uncalibrated date as our first proposal. Than we make a second proposal, in relation to the first one.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bp</span><span class="w">
</span><span class="n">second_proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">first_proposal</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">)</span><span class="w">
</span><span class="n">second_proposal</span><span class="w">
</span></code></pre></div></div>

<p>Our second proposal is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 3555.349
</code></pre></div></div>

<p>With our likelihood function, we check how likely this second proposal is:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ratio</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">second_proposal</span><span class="p">)</span><span class="o">/</span><span class="n">likelihood</span><span class="p">(</span><span class="n">first_proposal</span><span class="p">)</span><span class="w">
</span><span class="n">ratio</span><span class="w">

</span><span class="c1">## [1] 3.353998e-10</span><span class="w">
</span></code></pre></div></div>

<p>The second proposal is 3.3539984 * 10<sup>-10</sup> times likely compared to the first.</p>

<h2 id="solution-two-evaluation-with-a-random-component-2">Solution Two: Evaluation with a random component</h2>

<p>If the ratio is more than 1 (second proposal is better), we keep it.</p>

<p>If it is less than one (second proposal is worse), we keep it with a probability equal to the ratio. Meaning, we roll a dice‚Ä¶</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">alpha</span><span class="w">

</span><span class="c1">## [1] 0.2552167</span><span class="w">
</span></code></pre></div></div>

<p>Check if our random value is smaller than our ratio.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ratio</span><span class="w">

</span><span class="c1">## [1] FALSE</span><span class="w">
</span></code></pre></div></div>

<p>That is false. So our second proposal will not be recorded, and will not be part of the Markov chain.</p>

<h1 id="everything-together">Everything together</h1>

<h2 id="the-final-code">The final code</h2>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">calf</span><span class="o">&lt;-</span><span class="n">approxfun</span><span class="p">(</span><span class="n">intcal13</span><span class="p">[,</span><span class="m">1</span><span class="p">],</span><span class="n">intcal13</span><span class="p">[,</span><span class="m">2</span><span class="p">])</span><span class="w">

</span><span class="n">likelihood</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">proposal</span><span class="p">){</span><span class="n">dnorm</span><span class="p">(</span><span class="n">calf</span><span class="p">(</span><span class="n">proposal</span><span class="p">),</span><span class="n">bp</span><span class="p">,</span><span class="n">std</span><span class="p">)}</span><span class="w">

</span><span class="c1">#Setup</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3600</span><span class="p">;</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="p">;</span><span class="w"> </span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span><span class="w">

</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">10000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">)</span><span class="w">
  </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span><span class="w">
  
  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">proposal_prob</span><span class="o">/</span><span class="n">last_prob</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="w"> </span><span class="n">proposal</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>With every loop, our collector records those proposals that were accepted, either because they were better, or because the were choosen in the relegation round‚Ä¶ due to the random factor.</p>

<h2 id="the-result">The result</h2>

<p>If we make a histogramm from the collected proposals, we get something that is essentially already the calibrated date:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">collector</span><span class="p">,</span><span class="n">probability</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/algorithm_result-1.png" alt="" /><!-- --></p>

<h2 id="compare-the-result">Compare the result</h2>

<p>We can compare the resulting histogram with a calibration from Oxcal: looks similar!</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/algorithm_result_comp_1-1.png" alt="" /><!-- --></p>

<h2 id="see-it-run">See it run</h2>

<video loop="" autoplay="" autoresume=""><source src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/algorithm_live-.mp4" /><p>video of chunk algorithm_live</p></video>

<h1 id="adding-stratigraphical-informations">Adding stratigraphical informations</h1>

<h2 id="the-scenario">The Scenario</h2>

<p>We have two samples, S_1 (3600, 30) and S_2 (3550, 40).
We know from the stratigraphy, that S_1 must be younger than S_2.</p>

<p>We can easily introduce this information into our calibration with a little extra code.</p>

<h2 id="the-new-code">The new code</h2>

<p>First step: Calibrate multiple dates at once. For this, we add another dimension to our variables (bp, std, collector, last_prob), to reflect the fact that we now deal with multiple data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Setup</span><span class="w">
</span><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">3600</span><span class="p">,</span><span class="w"> </span><span class="m">3550</span><span class="p">);</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">30</span><span class="p">,</span><span class="m">40</span><span class="p">)</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">date1</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">date2</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="w">
</span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="m">2</span><span class="p">]))</span><span class="w">

</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">20000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">curr_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="m">-1</span><span class="p">)</span><span class="o">%%</span><span class="m">2+1</span><span class="w"> </span><span class="c1"># alter between 1 and 2</span><span class="w">
  </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">[</span><span class="n">curr_date</span><span class="p">])</span><span class="w">
  </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">proposal</span><span class="p">)[</span><span class="n">curr_date</span><span class="p">]</span><span class="w">
  
  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">proposal_prob</span><span class="o">/</span><span class="n">last_prob</span><span class="p">[</span><span class="n">curr_date</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="n">last_prob</span><span class="p">[</span><span class="n">curr_date</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="w"> </span><span class="n">proposal</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="the-result-1">The result</h2>

<p>If we now let the code run, we can calibrate two dates at once:</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/cal_multi-1.png" alt="" /><!-- --></p>

<h2 id="the-new-code-1">The new code</h2>

<p>Second step: Alter the Metropolis-Hastings -&gt; Gibbs Sampling
We add another condition:</p>

<p>If calibrating for the first date (S_1), every proposal must be younger than the last proposal for the second date (S_2), and vice versa,</p>

<p>If calibrating for the second date (S_2), every proposal must be older than the last proposal for the second date (S_1)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Setup</span><span class="w">
</span><span class="n">bp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">3600</span><span class="p">,</span><span class="w"> </span><span class="m">3550</span><span class="p">);</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">30</span><span class="p">,</span><span class="m">40</span><span class="p">)</span><span class="w">
</span><span class="n">collector</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">date1</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">date2</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="w">
</span><span class="n">last_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="m">2</span><span class="p">]))</span><span class="w">

</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">20000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">curr_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="m">-1</span><span class="p">)</span><span class="o">%%</span><span class="m">2+1</span><span class="w"> </span><span class="c1"># alter between 1 and 2</span><span class="w">
  </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="n">std</span><span class="p">[</span><span class="n">curr_date</span><span class="p">])</span><span class="w">
  </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">likelihood</span><span class="p">(</span><span class="n">proposal</span><span class="p">)[</span><span class="n">curr_date</span><span class="p">]</span><span class="w">
  
</span><span class="c1"># This is the new bit!</span><span class="w">
</span><span class="c1">#####################################################</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_date</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">proposal</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="m">2</span><span class="p">]],</span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_date</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="c1">#####################################################</span><span class="w">
  
  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">proposal_prob</span><span class="o">/</span><span class="n">last_prob</span><span class="p">[</span><span class="n">curr_date</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="n">last_prob</span><span class="p">[</span><span class="n">curr_date</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">proposal_prob</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">proposal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">collector</span><span class="p">[[</span><span class="n">curr_date</span><span class="p">]],</span><span class="w"> </span><span class="n">proposal</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="the-result-2">The result</h2>
<p>Now we can see the modeled date according to our stratigraphic information:</p>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-17-1.png" alt="" /><!-- --></p>

<p>Both dates can again be compared against the Oxcal output:</p>

<h2 id="compare-to-oxcal-unmodeled">Compare to Oxcal unmodeled</h2>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-18-1.png" alt="" /><!-- --></p>

<h2 id="compare-to-oxcal-modeled">Compare to Oxcal modeled</h2>

<p><img src="/assets/posts/2017-01-23-14c-calibration-the-bayesian-way/unnamed-chunk-19-1.png" alt="" /><!-- --></p>

<h1 id="result">Result</h1>

<p><strong>Voila, Oxcal reverse engineered!</strong></p>
:ET