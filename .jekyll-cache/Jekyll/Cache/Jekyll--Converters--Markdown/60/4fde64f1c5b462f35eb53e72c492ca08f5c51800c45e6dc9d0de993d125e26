I"ì$
<p>Calibration of <sup>14</sup>C dates is one of the more common tasks an
archaeologists has to do. I will not go into the details of the details
why calibration is necessary here (maybe in another post), but I want to
give in this post and in some follow ups hands on instruction how a
calibration can be archieved using R. This series will be published also
at the <a href="https://www.github.com/ISAAKiel">ISAAKiel-Repository</a>.</p>

<!--more-->

<h2 id="the-short-story">The short story</h2>

<p>Everything, what follows, is an explanation of these 5 lines of code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cal_curve &lt;- read.csv(
  url("http://www.radiocarbon.org/IntCal13%20files/intcal13.14c"),
  skip=11, 
  header=F)
cal_matrix &lt;- sapply(cal_curve[,1],function(x) {
  dnorm(x,mean = cal_curve[,2],sd = cal_curve[,3])
  })
my_prob_date &lt;- dnorm(cal_curve[,1], mean = 4000, sd = 25)
my_cal_date &lt;- as.vector(cal_matrix %*% my_prob_date)
plot(cal_curve[,1],my_cal_date,type="l",xlim=c(4350,4600))
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/short_story-1.png" alt="" /></p>

<p>Got it? Fine! If not, continue readingâ€¦</p>

<h2 id="getting-the-calibration-curve">Getting the Calibration Curve</h2>

<p>For calibration we need two things: A date and the calibration curve.</p>

<p>Starting with the latter, you can <a href="">obtain it at Radiocarbon</a>. You can
download it or access it directly from inside R, like I did in the upper
code snippet. I will now go for the first alternative.</p>

<p>If you have downloaded it, you may like to inspect the file. It is
essentially a csv file, with a header spanning 11 rows. To load it into
your R, you can use the <code class="language-plaintext highlighter-rouge">read.csv</code> function, with skipping the first 11
rows, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cal_curve &lt;- read.csv("/path/to/your/calcurve",
                      skip=11,
                      header = F)
</code></pre></div></div>

<p>The data set contains several columns that are named in the header in a
style not very conveniently for R users. We therefor name the columns
manually:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colnames(cal_curve) &lt;- c("CAL BP", 
                         "14C age",
                         "Error",
                         "Delta 14C",
                         "Sigma")
</code></pre></div></div>

<p>Having the first component at hand, we proceed to arranging a date.</p>

<h2 id="making-a-date">Making a date</h2>

<p>What follows will be very simple: A <sup>14</sup>C date consists of two
components, a BP (before present in <sup>14</sup>C years) and a standard
deviation of the measurement. I will make a simple vector reflecting
this structure, and since I am overly enthusiastic, I will also name the
vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_date &lt;- c(4000, 25)
names(my_date) &lt;- c("bp", "std")
</code></pre></div></div>

<h2 id="transforming-the-curve-to-a-matrix">Transforming the â€˜curveâ€™ to a matrix</h2>

<p>Probably one of the most easy ways to calibrate a date is to use the
calibration curve as transformation matrix. In the curve file we have
information on the calibrated bp dates, the related <sup>14</sup>C age and the
error in years. Each of these value groups can be understood as
probability distribution. Eg. for:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cal_curve[4500,]

##      CAL BP 14C age Error Delta 14C Sigma
## 4500   3205    3002    10      14.1   1.3
</code></pre></div></div>

<p>the calibrated bp year of 3205 results from a 14C age of 3002 with an
error of 10, or from a normal distribution with a mean of 3002 and a
standard deviation of 10 years:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years_to_show &lt;- seq(2950,3050,by=5)
cal_curve_entry&lt;-dnorm(years_to_show,3002,10)
plot(years_to_show,cal_curve_entry, type="l")
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/plot_calcurve_entry_dist-1.png" alt="" /></p>

<p>We can proceed with other dates (note: the libraries are only included to enhance the plot):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(reshape2)
library(ggplot2)

years_to_show &lt;- seq(2800,3050,by=5)
cal_curve_range &lt;- cal_curve[4500:4540,]
cal_curve_entry_range &lt;- apply(cal_curve_range,
                               1,
                               function(x) {
                                 dnorm(years_to_show,x[2],x[3])
                                 }
                               )
rownames(cal_curve_entry_range)&lt;-years_to_show
cal_curve_entry_range[cal_curve_entry_range&lt;1e-3]&lt;-NA
dates_for_ggplot&lt;-melt(t(cal_curve_entry_range))

m &lt;- ggplot(dates_for_ggplot,aes(x=Var2,y=value,group=Var1))
graph &lt;- m + 
         geom_area() + 
         facet_grid(Var1 ~ .) + 
         scale_x_continuous("BP")
show(graph)

## Warning: Removed 1540 rows containing missing values (position_stack).
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/plot_multiple_calcurve_entry_dist-1.png" alt="" /></p>

<p>Compare the calibration curve for the respective time window:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cal_curve_for_ggplot&lt;-data.frame(bp=cal_curve_range[,1],
                                 c14=cal_curve_range[,2])

m &lt;- ggplot(cal_curve_for_ggplot,aes(x=bp,y=c14))
graph &lt;- m + geom_line() + coord_flip()
show(graph)
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/plot_calcurve_to_compare-1.png" alt="" /></p>

<p>The message of this is: The calibration curve can be expressed as matrix
of probabilities, mapping one <sup>14</sup>C year to one calendric BP year. Such
a matrix can be constructed like that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years &lt;- cal_curve[,'CAL BP']

cal_matrix &lt;- sapply(years,function(x) {
  dnorm(x,mean = cal_curve[,'14C age'],sd = cal_curve[,'Error'])
  })

rownames(cal_matrix)&lt;-colnames(cal_matrix)&lt;-years
</code></pre></div></div>

<h2 id="calibration-by-using-the-calibration-curve-as-transformation-matrix">Calibration by using the calibration curve as transformation matrix</h2>

<p>This matrix we just created can be used to transform a vector of
probabilities to a calibrated vector of probabilities. We have our date:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_date

##   bp  std 
## 4000   25
</code></pre></div></div>

<p>which represents a normal distributed density function with mean bp and
standard deviation std. This can be expressed, with our years vector,
as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_prob_date &lt;- dnorm(years, 
                      mean = my_date['bp'], 
                      sd = my_date['std'])
plot(years,my_prob_date,type = 'l')
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/plot_uncal_date_probs-1.png" alt="" /></p>

<p>or if we zoom in to only the relevant parts</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_prob_date.window &lt;- cbind(years,my_prob_date)
my_prob_date.window &lt;- my_prob_date.window[my_prob_date.window[,2] &gt; 1e-3,]
plot(my_prob_date.window,type = 'l')
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/plot_uncal_date_probs_zoomed-1.png" alt="" /></p>

<p>Now we can just multiply our vector with the transformation matrix to
get a calibrated result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_cal_date &lt;- as.vector(cal_matrix %*% my_prob_date)
# normalize, so that it sums up to 1
my_cal_date &lt;- my_cal_date / sum(my_cal_date)
plot(years, my_cal_date, type = 'l', xlim=c(4350,4600))
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/do_the_calibration-1.png" alt="" /></p>

<p>Compare this to a Â´BchronÂ´ calibration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(Bchron)

## Loading required package: inline

plot(
  Bchron::BchronCalibrate(4000,
                          25,
                          calCurves = 'intcal13'),
  xlim=c(4350,4600)
)
</code></pre></div></div>

<p><img src="/assets/posts/2016-06-03-14c-calibration-1/compare_to_bchron-1.png" alt="" /></p>

<p>Looks pretty similar, doesnâ€™t it?</p>

<p>Remember: it are essentially 4 steps in total to come from a date to a
calibrated one, it is not rocket science. And 1 of them represents
getting the curve, two other reshaping the calibration curve and the
date, while only in one step you can do the calibration itself. Simple,
isnâ€™t it?</p>
:ET